# create a cluster with gcp workload identity using CCO manual mode
# pre-req: ssh-add ~/.ssh/id_rsa
znap function create-ocp-gcp-wif(){
    # Use specified openshift-install or default to 4.19.0-ec.4
    # local OPENSHIFT_INSTALL=./Downloads/openshift-install-mac-4.19.0-ec.4/openshift-install
    local OPENSHIFT_INSTALL=${OPENSHIFT_INSTALL:-openshift-install-4.19.0-ec.4}
    $OPENSHIFT_INSTALL version
    # Check if help is requested
    if [[ $1 == "help" ]]; then
        echo "Usage: create-ocp-gcp-wif [OPTION]"
        echo "Create an OpenShift cluster on GCP with Workload Identity Federation"
        echo ""
        echo "Options:"
        echo "  help      Display this help message"
        echo "  gather    Gather bootstrap logs from the installation directory"
        echo "  delete    Just delete the cluster without recreating it"
        echo "  no-delete Skip deletion of existing cluster before creation"
        echo ""
        echo "Prerequisites:"
        echo "  - GCP_PROJECT_ID environment variable must be set"
        echo "  - GCP_REGION environment variable must be set"
        echo "  - GCP_BASEDOMAIN environment variable must be set"
        echo "  - SSH key must be added to the agent (ssh-add ~/.ssh/id_rsa)"
        echo "  - Pull secret must exist at ~/pull-secret.txt"
        echo ""
        echo "Directory:"
        echo "  Installation files will be created in: $OCP_MANIFESTS_DIR/$TODAY-gcp-wif"
        echo ""
        echo "Note:"
        echo "  When creating clusters alongside existing ones (option 3), a unique"
        echo "  name will be generated by adding a suffix (e.g., -1, -2) to avoid conflicts"
        return 0
    fi
    
    # openshift-install create install-config --dir $OCP_MANIFESTS_DIR/$TODAY-gcp-wif --log-level debug
    # https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html-single/installing_on_gcp/index#cco-ccoctl-configuring_installing-gcp-customizations
    # prompt and remove if exists already so user can interrupt if uninstall is needed.
    OCP_CREATE_DIR=$OCP_MANIFESTS_DIR/$TODAY-gcp-wif
    CLUSTER_BASE_NAME=tkaovila-$TODAY-wif
    CLUSTER_NAME=$CLUSTER_BASE_NAME #max 21 char allowed
    
    # Check if we need to modify the cluster name to avoid conflicts
    # This happens when option 3 (proceed alongside existing) was selected
    if [[ -n "$PROCEED_WITH_EXISTING_CLUSTERS" && "$PROCEED_WITH_EXISTING_CLUSTERS" == "true" ]]; then
        # Look for existing clusters with the same base name
        local suffix_num=1
        # Search for existing directories with similar names
        while find "$OCP_MANIFESTS_DIR" -type d -name "*${CLUSTER_BASE_NAME}*" 2>/dev/null | grep -q .; do
            # Try appending increasing numbers until we find a unique name
            CLUSTER_NAME="${CLUSTER_BASE_NAME}-${suffix_num}"
            echo "Found existing cluster with similar name, trying: $CLUSTER_NAME"
            # Check if the new name exists
            if ! find "$OCP_MANIFESTS_DIR" -type d -name "*${CLUSTER_NAME}*" 2>/dev/null | grep -q .; then
                # Found a unique name
                OCP_CREATE_DIR=$OCP_MANIFESTS_DIR/$TODAY-gcp-wif-$suffix_num
                echo "Using unique cluster name: $CLUSTER_NAME and directory: $OCP_CREATE_DIR"
                break
            fi
            ((suffix_num++))
            # Safety check to avoid infinite loop
            if [[ $suffix_num -gt 10 ]]; then
                echo "ERROR: Cannot find a unique cluster name after 10 attempts"
                return 1
            fi
        done
    fi
    if [[ $1 == "gather" ]]; then
        $OPENSHIFT_INSTALL gather bootstrap --dir $OCP_CREATE_DIR || return 1
        return 0
    fi
    if [[ $1 != "no-delete" ]]; then
        $OPENSHIFT_INSTALL destroy cluster --dir $OCP_CREATE_DIR || echo "no existing cluster"
        $OPENSHIFT_INSTALL destroy bootstrap --dir $OCP_CREATE_DIR || echo "no existing bootstrap"
        (ccoctl gcp delete \
        --name $CLUSTER_NAME \
        --project $GCP_PROJECT_ID \
        --credentials-requests-dir $OCP_CREATE_DIR/credentials-requests && echo "cleaned up ccoctl gcp resources") || true
        ((rm -r $OCP_CREATE_DIR && echo "removed existing create dir") || (true && echo "no existing install dir")) || return 1
    fi
    # if param is delete then stop here
    if [[ $1 == "delete" ]]; then
        return 0
    fi
    
    # Check for existing clusters before proceeding
    check-for-existing-clusters "gcp" || return 1
    
    mkdir -p $OCP_CREATE_DIR && \
    echo "additionalTrustBundlePolicy: Proxyonly
apiVersion: v1
baseDomain: $GCP_BASEDOMAIN
compute:
- architecture: amd64
  hyperthreading: Enabled
  name: worker
  platform: {}
  replicas: 3
controlPlane:
  architecture: amd64
  hyperthreading: Enabled
  name: master
  platform: {}
  replicas: 3
metadata:
  creationTimestamp: null
  name: $CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: 23
  machineNetwork:
  - cidr: 10.0.0.0/16
  networkType: OVNKubernetes
  serviceNetwork:
  - 172.30.0.0/16
platform:
  gcp:
    projectID: $GCP_PROJECT_ID
    region: $GCP_REGION
publish: External
credentialsMode: Manual # needed for WIF at the time of prior writing at https://github.com/openshift/oadp-operator/wiki/GCP-WIF-Authentication-on-OpenShift
pullSecret: '$(cat ~/pull-secret.txt)'
sshKey: |
  $(cat ~/.ssh/id_rsa.pub)
" > $OCP_CREATE_DIR/install-config.yaml && echo "created install-config.yaml" || return 1
# GCP only supports AMD64 architecture, so use the specific release image
RELEASE_IMAGE=$OCP_FUNCTIONS_RELEASE_IMAGE_MULTI
# RELEASE_IMAGE=$($OPENSHIFT_INSTALL version | awk '/release image/ {print $3}')
# make sure logged into registry since cco steps requires it.
BASE_RELEASE_IMAGE_REGISTRY=$(echo $RELEASE_IMAGE | awk -F/ '{print $1}')

echo INFO checking if podman is logged into $BASE_RELEASE_IMAGE_REGISTRY
podman login $BASE_RELEASE_IMAGE_REGISTRY || if [ "$BASE_RELEASE_IMAGE_REGISTRY" = "registry.ci.openshift.org" ]; then
  open "https://oauth-openshift.apps.ci.l2s4.p1.openshiftapps.com/oauth/authorize?client_id=openshift-browser-client&redirect_uri=https%3A%2F%2Foauth-openshift.apps.ci.l2s4.p1.openshiftapps.com%2Foauth%2Ftoken%2Fdisplay&response_type=code"
  echo "Login URL opened in browser. Please copy the login command from the browser and paste it below:"
  read login_command
  echo "Executing login command..."
  eval "$login_command"
fi

# Update pull-secret.txt with podman auth credentials if logged in
if podman login --get-login $BASE_RELEASE_IMAGE_REGISTRY &>/dev/null; then
  echo "INFO: Podman is logged into $BASE_RELEASE_IMAGE_REGISTRY, updating pull-secret.txt"
  
  # Get podman auth file location and extract credentials
  PODMAN_AUTH_FILE="${XDG_RUNTIME_DIR}/containers/auth.json"
  if [ ! -f "$PODMAN_AUTH_FILE" ]; then
    PODMAN_AUTH_FILE="$HOME/.config/containers/auth.json"
  fi
  
  if [ -f "$PODMAN_AUTH_FILE" ]; then
    # Extract auth for the specific registry
    REGISTRY_AUTH=$(jq -r --arg reg "$BASE_RELEASE_IMAGE_REGISTRY" '.auths[$reg] // empty' "$PODMAN_AUTH_FILE")
    
    if [ -n "$REGISTRY_AUTH" ]; then
      # Read current pull secret
      PULL_SECRET=$(cat ~/pull-secret.txt)
      
      # Update pull secret with the registry auth
      UPDATED_PULL_SECRET=$(echo "$PULL_SECRET" | jq --arg reg "$BASE_RELEASE_IMAGE_REGISTRY" --argjson auth "$REGISTRY_AUTH" '.auths[$reg] = $auth')
      
      # Write back to pull-secret.txt
      echo "$UPDATED_PULL_SECRET" > ~/pull-secret.txt
      echo "INFO: Updated ~/pull-secret.txt with credentials for $BASE_RELEASE_IMAGE_REGISTRY"
    else
      echo "WARN: No auth found for $BASE_RELEASE_IMAGE_REGISTRY in podman auth file"
    fi
  else
    echo "WARN: Podman auth file not found at expected locations"
  fi
fi
echo "INFO: Using AMD64 architecture release image for GCP: $RELEASE_IMAGE"

# Export the release image override
export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$RELEASE_IMAGE
echo "INFO: Exported OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$RELEASE_IMAGE"
# Extract the list of CredentialsRequest custom resources (CRs) from the OpenShift Container Platform release image by running the following command:
echo "extracting credential-requests" && oc adm release extract \
  --from=$RELEASE_IMAGE \
  --credentials-requests \
  --included \
  --install-config=$OCP_CREATE_DIR/install-config.yaml \
  --to=$OCP_CREATE_DIR/credentials-requests || return 1 #credential requests are stored in credentials-requests dir
ccoctl gcp create-all \
--name $CLUSTER_NAME \
--project $GCP_PROJECT_ID \
--region $GCP_REGION \
--output-dir $OCP_CREATE_DIR \
--credentials-requests-dir $OCP_CREATE_DIR/credentials-requests || return 1
    $OPENSHIFT_INSTALL create manifests --dir $OCP_CREATE_DIR || return 1
    cp $OCP_CREATE_DIR/credentials-requests/* $OCP_CREATE_DIR/manifests/ || return 1 # copy cred requests to manifests dir, ccoctl delete will delete cred requests in separate dir
    
    # Create the cluster
    $OPENSHIFT_INSTALL create cluster --dir $OCP_CREATE_DIR \
        --log-level=info || $OPENSHIFT_INSTALL gather bootstrap --dir $OCP_CREATE_DIR || return 1
    
    # Unset the release image override after use
    echo "INFO: Unsetting OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE"
    unset OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE
        
    # Reset the flag to avoid affecting future cluster creations
    if [[ -n "$PROCEED_WITH_EXISTING_CLUSTERS" ]]; then
        unset PROCEED_WITH_EXISTING_CLUSTERS
    fi
}
