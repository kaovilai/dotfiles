# create a cluster with azure workload identity using CCO manual mode
# pre-req: ssh-add ~/.ssh/id_rsa
znap function create-ocp-azure-sts(){
    # Unset SSH_AUTH_SOCK on Darwin systems to avoid SSH errors
    if [[ "$(uname)" == "Darwin" ]]; then
        unset SSH_AUTH_SOCK
    fi
    
    # Get openshift-install binary
    local OPENSHIFT_INSTALL=$(get_openshift_install)
    [[ -z "$OPENSHIFT_INSTALL" ]] && return 1
    $OPENSHIFT_INSTALL version
    # Check if help is requested
    if [[ $1 == "help" ]]; then
        echo "Usage: create-ocp-azure-sts [OPTION]"
        echo "Create an OpenShift cluster on Azure with Workload Identity Federation"
        echo ""
        echo "Options:"
        echo "  help        Display this help message"
        echo "  gather      Gather bootstrap logs from the installation directory"
        echo "  delete      Just delete the cluster without recreating it"
        echo "  no-delete   Skip deletion of existing cluster before creation"
        echo "  --force-new Force creation alongside existing clusters (skip prompt)"
        echo "  --ec        Automatically select Early Candidate release stream"
        echo ""
        echo "Prerequisites:"
        echo "  - AZURE_SUBSCRIPTION_ID environment variable must be set"
        echo "  - AZURE_TENANT_ID environment variable must be set"
        echo "  - AZURE_REGION environment variable must be set"
        echo "  - AZURE_BASEDOMAIN environment variable must be set"
        echo "  - AZURE_BASEDOMAIN_RESOURCE_GROUP environment variable must be set (contains DNS zone)"
        echo "  - SSH key must be added to the agent (ssh-add ~/.ssh/id_rsa)"
        echo "  - Pull secret must exist at ~/pull-secret.txt"
        echo "  - Azure CLI must be installed and logged in (az login)"
        echo "  - Azure CLI must be set to the correct subscription"
        echo ""
        echo "Automatic service principal handling:"
        echo "  - A service principal will be automatically created if needed (named: <username>-openshift-installer)"
        echo "  - Credentials are saved to: ~/.azure/osServicePrincipal.json"
        echo "  - Set AZURE_AUTH_LOCATION to use a different location"
        echo "  - If the service principal already exists, credentials will be refreshed"
        echo "  - Required roles (automatically assigned if missing):"
        echo "    - Contributor: For managing Azure resources"
        echo "    - User Access Administrator: For creating role assignments for managed identities"
        echo ""
        echo "Resource Groups:"
        echo "  - A unique resource group will be created for each cluster: <cluster-name>-rg"
        echo "  - The DNS zone resource group (AZURE_BASEDOMAIN_RESOURCE_GROUP) must exist and contain the DNS zone"
        echo "  - Do NOT set AZURE_RESOURCE_GROUP - it will be auto-generated to avoid conflicts"
        echo ""
        echo "Directory:"
        echo "  Installation files will be created in: $OCP_MANIFESTS_DIR/$TODAY-azure-sts"
        echo ""
        echo "Note:"
        echo "  When creating clusters alongside existing ones (option 3), a unique"
        echo "  name will be generated by adding a suffix (e.g., -1, -2) to avoid conflicts"
        echo "  The --force-new flag automatically selects option 3 when existing clusters are found"
        echo "  The --ec flag automatically selects the Early Candidate release stream"
        return 0
    fi
    
    # Safety check - ensure TODAY is not empty
    if [[ -z "$TODAY" ]]; then
        echo "WARNING: TODAY variable is empty, using current date"
        TODAY=$(date +%Y%m%d)
    fi
    
    # Set initial cluster name and directory
    local CLUSTER_BASE_NAME="tkaovila-$TODAY-sts"
    local OCP_CREATE_DIR_BASE="$OCP_MANIFESTS_DIR/$TODAY-azure-sts"
    
    # Generate unique cluster name if needed
    local unique_result=$(generate_unique_cluster_name "$CLUSTER_BASE_NAME" "$OCP_CREATE_DIR_BASE")
    [[ -z "$unique_result" ]] && return 1
    local CLUSTER_NAME=$(echo "$unique_result" | grep "cluster_name:" | cut -d: -f2)
    local OCP_CREATE_DIR=$(echo "$unique_result" | grep "cluster_dir:" | cut -d: -f2)
    
    # Generate unique resource group name for the cluster
    local CLUSTER_RESOURCE_GROUP="${CLUSTER_NAME}-rg"
    echo "INFO: Cluster will be created in resource group: $CLUSTER_RESOURCE_GROUP"
    
    # Generate valid Azure storage account name (3-24 chars, lowercase letters and numbers only)
    local STORAGE_ACCOUNT_NAME=$(echo "$CLUSTER_NAME" | tr -d '-' | tr '[:upper:]' '[:lower:]' | cut -c1-24)
    if [[ $1 == "gather" ]]; then
        if [[ -d "$OCP_CREATE_DIR" ]]; then
            $OPENSHIFT_INSTALL gather bootstrap --dir $OCP_CREATE_DIR || return 1
        else
            echo "Directory $OCP_CREATE_DIR does not exist, cannot gather bootstrap logs"
            return 1
        fi
        return 0
    fi
    if [[ $1 != "no-delete" ]]; then
        if [[ -d "$OCP_CREATE_DIR" ]]; then
            $OPENSHIFT_INSTALL destroy cluster --dir $OCP_CREATE_DIR || echo "no existing cluster"
            $OPENSHIFT_INSTALL destroy bootstrap --dir $OCP_CREATE_DIR || echo "no existing bootstrap"
            (retry_ccoctl_azure azure delete \
            --name $CLUSTER_NAME \
            --subscription-id $AZURE_SUBSCRIPTION_ID \
            --region $AZURE_REGION \
            --storage-account-name $STORAGE_ACCOUNT_NAME \
            --delete-oidc-resource-group && echo "cleaned up ccoctl azure resources") || true
            rm -rf $OCP_CREATE_DIR && echo "removed existing create dir" || echo "no existing install dir"
        else
            echo "Directory $OCP_CREATE_DIR does not exist, nothing to delete"
        fi
    fi
    # if param is delete then stop here
    if [[ $1 == "delete" ]]; then
        return 0
    fi
    
    # Validate required Azure environment variables
    validate_env_vars "azure" \
        AZURE_SUBSCRIPTION_ID \
        AZURE_TENANT_ID \
        AZURE_REGION \
        AZURE_BASEDOMAIN \
        AZURE_BASEDOMAIN_RESOURCE_GROUP || return 1
    
    # Ensure Azure CLI is authenticated to avoid installer prompts
    echo "INFO: Checking Azure CLI authentication status..."
    if ! az account show &>/dev/null; then
        echo "ERROR: Azure CLI is not authenticated. Please run 'az login' first."
        return 1
    fi
    
    # Verify we're using the correct subscription
    local current_sub=$(az account show --query id -o tsv)
    if [[ "$current_sub" != "$AZURE_SUBSCRIPTION_ID" ]]; then
        echo "INFO: Switching to subscription $AZURE_SUBSCRIPTION_ID..."
        az account set --subscription "$AZURE_SUBSCRIPTION_ID" || {
            echo "ERROR: Failed to set Azure subscription. Please ensure you have access to subscription $AZURE_SUBSCRIPTION_ID"
            return 1
        }
    fi
    
    # Export Azure credentials for the installer to avoid prompts
    # The installer looks for these environment variables to skip interactive prompts
    # Check if AZURE_AUTH_LOCATION is set but empty
    if [[ -z "$AZURE_AUTH_LOCATION" ]]; then
        export AZURE_AUTH_LOCATION="$HOME/.azure/osServicePrincipal.json"
    fi
    
    # Check if service principal credentials file exists and contains valid JSON
    local need_new_credentials=false
    if [[ ! -f "$AZURE_AUTH_LOCATION" ]]; then
        echo "INFO: Azure service principal credentials file not found at $AZURE_AUTH_LOCATION"
        need_new_credentials=true
    else
        # Check if existing file contains valid JSON
        if ! jq . "$AZURE_AUTH_LOCATION" >/dev/null 2>&1; then
            echo "WARNING: Existing credentials file contains invalid JSON"
            need_new_credentials=true
        elif [[ ! -s "$AZURE_AUTH_LOCATION" ]]; then
            echo "WARNING: Existing credentials file is empty"
            need_new_credentials=true
        else
            # Check for required keys in the JSON
            # The SDK auth format should have: clientId, clientSecret, subscriptionId, tenantId
            local missing_keys=""
            for key in clientId clientSecret subscriptionId tenantId; do
                if ! jq -e ".$key" "$AZURE_AUTH_LOCATION" >/dev/null 2>&1; then
                    missing_keys="$missing_keys $key"
                fi
            done
            
            if [[ -n "$missing_keys" ]]; then
                echo "WARNING: Existing credentials file is missing required keys:$missing_keys"
                need_new_credentials=true
            fi
        fi
    fi
    
    if [[ "$need_new_credentials" == "true" ]]; then
        echo "INFO: Creating service principal to avoid authentication prompts..."
        
        # Get current Azure user to create a unique service principal name
        local azure_user=$(az account show --query user.name -o tsv | cut -d@ -f1)
        local sp_name="${azure_user}-openshift-installer"
        
        # Check if service principal already exists
        local existing_sp=$(az ad sp list --filter "displayName eq '$sp_name'" --query "[0].appId" -o tsv 2>/dev/null)
        
        # Ensure the directory exists
        mkdir -p "$(dirname "$AZURE_AUTH_LOCATION")"
        
        if [[ -n "$existing_sp" ]]; then
            echo "INFO: Service principal '$sp_name' already exists (appId: $existing_sp)"
            echo "INFO: Recreating credentials file..."
            
            # Reset the service principal credentials
            echo "DEBUG: Running: az ad sp credential reset --id '$existing_sp'"
            # Capture only stdout, let stderr go to console for warnings
            local sp_reset=$(az ad sp credential reset --id "$existing_sp" --query "{appId:appId, password:password, tenant:tenant}" -o json)
            local az_exit_code=$?
            
            if [[ $az_exit_code -ne 0 ]]; then
                echo "ERROR: az command failed with exit code $az_exit_code"
                echo "DEBUG: Output: $sp_reset"
                return 1
            fi
            
            if [[ -z "$sp_reset" ]] || [[ "$sp_reset" == "null" ]]; then
                echo "ERROR: Failed to reset credentials for existing service principal"
                echo "INFO: You may need to manually create the service principal"
                return 1
            fi
            
            # Extract values from reset output
            local app_id=$(echo "$sp_reset" | jq -r .appId)
            local password=$(echo "$sp_reset" | jq -r .password)
            local tenant=$(echo "$sp_reset" | jq -r .tenant)
            
            # Debug: Check if values were extracted correctly
            echo "DEBUG: Extracted values:"
            echo "DEBUG: app_id='$app_id'"
            echo "DEBUG: password='***' (hidden)"
            echo "DEBUG: tenant='$tenant'"
            echo "DEBUG: AZURE_SUBSCRIPTION_ID='$AZURE_SUBSCRIPTION_ID'"
            
            # Validate extracted values
            if [[ -z "$app_id" ]] || [[ "$app_id" == "null" ]] || [[ -z "$password" ]] || [[ "$password" == "null" ]] || [[ -z "$tenant" ]] || [[ "$tenant" == "null" ]]; then
                echo "ERROR: Failed to extract values from service principal reset output"
                echo "DEBUG: Raw reset output: $sp_reset"
                return 1
            fi
            
            # Create SDK auth format JSON for OpenShift installer
            local sp_creds=$(jq -n \
                --arg clientId "$app_id" \
                --arg clientSecret "$password" \
                --arg subscriptionId "$AZURE_SUBSCRIPTION_ID" \
                --arg tenantId "$tenant" \
                '{clientId: $clientId, clientSecret: $clientSecret, subscriptionId: $subscriptionId, tenantId: $tenantId}')
            
            echo "DEBUG: Writing credentials to: $AZURE_AUTH_LOCATION"
            echo "DEBUG: Credentials JSON (with hidden password):"
            echo "$sp_creds" | jq '.clientSecret = "***"'
            echo "$sp_creds" > "$AZURE_AUTH_LOCATION"
            echo "DEBUG: File written successfully"
            
            # Verify the file was written correctly
            if [[ -f "$AZURE_AUTH_LOCATION" ]]; then
                local written_client_id=$(jq -r .clientId "$AZURE_AUTH_LOCATION" 2>/dev/null)
                if [[ -z "$written_client_id" ]] || [[ "$written_client_id" == "null" ]]; then
                    echo "ERROR: File was written but clientId is empty or null"
                    echo "DEBUG: File contents:"
                    jq '.clientSecret = "***"' "$AZURE_AUTH_LOCATION" 2>/dev/null || cat "$AZURE_AUTH_LOCATION"
                fi
            fi
        else
            echo "INFO: Creating new service principal '$sp_name'..."
            
            # Create service principal with Contributor role using JSON auth format
            echo "DEBUG: Running: az ad sp create-for-rbac --name '$sp_name' --role Contributor --scopes /subscriptions/$AZURE_SUBSCRIPTION_ID --json-auth"
            # Capture only stdout, let stderr go to console for warnings
            local sp_creds=$(az ad sp create-for-rbac \
                --name "$sp_name" \
                --role Contributor \
                --scopes /subscriptions/$AZURE_SUBSCRIPTION_ID \
                --json-auth)
            local az_exit_code=$?
            
            if [[ $az_exit_code -ne 0 ]]; then
                echo "ERROR: az command failed with exit code $az_exit_code"
                echo "DEBUG: Output: $sp_creds"
                return 1
            fi
            
            if [[ -z "$sp_creds" ]] || [[ "$sp_creds" == "null" ]]; then
                echo "ERROR: Failed to create service principal"
                echo "INFO: You may need appropriate permissions to create service principals"
                return 1
            fi
            
            # Validate JSON before writing
            if ! echo "$sp_creds" | jq . >/dev/null 2>&1; then
                echo "ERROR: Invalid JSON returned from service principal creation"
                echo "DEBUG: Response: $sp_creds"
                return 1
            fi
            
            echo "DEBUG: Writing credentials to: $AZURE_AUTH_LOCATION"
            echo "DEBUG: Credentials JSON (with hidden password):"
            echo "$sp_creds" | jq '.clientSecret = "***"'
            echo "$sp_creds" > "$AZURE_AUTH_LOCATION"
            echo "DEBUG: File written successfully"
            
            # Verify the file was written correctly
            if [[ -f "$AZURE_AUTH_LOCATION" ]]; then
                local written_client_id=$(jq -r .clientId "$AZURE_AUTH_LOCATION" 2>/dev/null)
                if [[ -z "$written_client_id" ]] || [[ "$written_client_id" == "null" ]]; then
                    echo "ERROR: File was written but clientId is empty or null"
                    echo "DEBUG: File contents:"
                    jq '.clientSecret = "***"' "$AZURE_AUTH_LOCATION" 2>/dev/null || cat "$AZURE_AUTH_LOCATION"
                fi
            fi
        fi
        
        echo "INFO: Service principal credentials saved to $AZURE_AUTH_LOCATION"
        echo "INFO: You may want to add 'export AZURE_AUTH_LOCATION=$AZURE_AUTH_LOCATION' to your shell profile"
    else
        echo "INFO: Using existing Azure service principal credentials from $AZURE_AUTH_LOCATION"
    fi
    
    # Check and ensure service principal has required roles
    echo "INFO: Checking service principal role assignments..."
    local sp_client_id=$(jq -r .clientId "$AZURE_AUTH_LOCATION" 2>/dev/null)
    if [[ -z "$sp_client_id" ]] || [[ "$sp_client_id" == "null" ]]; then
        echo "ERROR: Failed to read service principal client ID from $AZURE_AUTH_LOCATION"
        return 1
    fi
    
    # Check current role assignments
    local has_contributor=false
    local has_user_access_admin=false
    
    echo "INFO: Checking roles for service principal: $sp_client_id"
    local role_assignments=$(az role assignment list --assignee "$sp_client_id" --all --query "[].roleDefinitionName" -o tsv 2>/dev/null)
    
    while IFS= read -r role; do
        case "$role" in
            "Contributor")
                has_contributor=true
                ;;
            "User Access Administrator")
                has_user_access_admin=true
                ;;
        esac
    done <<< "$role_assignments"
    
    # Assign missing roles
    if [[ "$has_contributor" != "true" ]]; then
        echo "INFO: Assigning Contributor role to service principal..."
        az role assignment create \
            --assignee "$sp_client_id" \
            --role "Contributor" \
            --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID" || {
            echo "ERROR: Failed to assign Contributor role"
            return 1
        }
    else
        echo "INFO: Service principal already has Contributor role"
    fi
    
    if [[ "$has_user_access_admin" != "true" ]]; then
        echo "INFO: Assigning User Access Administrator role to service principal..."
        echo "INFO: This role is required for OpenShift to create role assignments for managed identities"
        az role assignment create \
            --assignee "$sp_client_id" \
            --role "User Access Administrator" \
            --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID" || {
            echo "ERROR: Failed to assign User Access Administrator role"
            echo "ERROR: You may need to manually assign this role with appropriate permissions"
            return 1
        }
    else
        echo "INFO: Service principal already has User Access Administrator role"
    fi
    
    echo "INFO: Service principal role verification complete"
    
    
    # Parse command line flags
    local force_new=false
    local auto_ec=false
    
    for arg in "$@"; do
        case "$arg" in
            --force-new)
                force_new=true
                ;;
            --ec)
                auto_ec=true
                ;;
        esac
    done
    
    # Set environment variables based on flags
    if [[ "$force_new" == "true" ]]; then
        export FORCE_NEW_CLUSTER="true"
    fi
    
    if [[ "$auto_ec" == "true" ]]; then
        export AUTO_SELECT_EC="true"
    fi
    
    # Check for existing clusters before proceeding
    check-for-existing-clusters "azure" || return 1
    
    # Unset the force flag after use
    [[ -n "$FORCE_NEW_CLUSTER" ]] && unset FORCE_NEW_CLUSTER
    
    # Prompt for release stream selection and get release image
    local stream
    if [[ -n "$AUTO_SELECT_EC" ]]; then
        stream="4-dev-preview"
        echo "Automatically selecting Early Candidate release stream"
        unset AUTO_SELECT_EC
    else
        stream=$(prompt_release_stream)
    fi
    local RELEASE_IMAGE=$(get_release_image "$stream" "multi")
    [[ -z "$RELEASE_IMAGE" ]] && return 1
    
    echo "INFO: Using release image: $RELEASE_IMAGE"
    # make sure logged into registry since cco steps requires it.
    BASE_RELEASE_IMAGE_REGISTRY=$(echo $RELEASE_IMAGE | awk -F/ '{print $1}')

    # Handle registry login and pull secret update
    handle_registry_login "$BASE_RELEASE_IMAGE_REGISTRY"
    update_pull_secret_with_podman "$BASE_RELEASE_IMAGE_REGISTRY"
    mkdir -p $OCP_CREATE_DIR && \
    echo "additionalTrustBundlePolicy: Proxyonly
apiVersion: v1
baseDomain: $AZURE_BASEDOMAIN
compute:
- architecture: amd64
  hyperthreading: Enabled
  name: worker
  platform: {}
  replicas: 3
controlPlane:
  architecture: amd64
  hyperthreading: Enabled
  name: master
  platform: {}
  replicas: 3
metadata:
  creationTimestamp: null
  name: $CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: 23
  machineNetwork:
  - cidr: 10.0.0.0/16
  networkType: OVNKubernetes
  serviceNetwork:
  - 172.30.0.0/16
platform:
  azure:
    region: $AZURE_REGION
    resourceGroupName: $CLUSTER_RESOURCE_GROUP
    baseDomainResourceGroupName: $AZURE_BASEDOMAIN_RESOURCE_GROUP
    networkResourceGroupName: $AZURE_NETWORK_RESOURCE_GROUP
    virtualNetwork: $AZURE_VIRTUAL_NETWORK
    controlPlaneSubnet: $AZURE_CONTROL_PLANE_SUBNET
    computeSubnet: $AZURE_COMPUTE_SUBNET
publish: External
credentialsMode: Manual # needed for STS
pullSecret: '$(cat ~/pull-secret.txt)'
sshKey: |
  $(cat ~/.ssh/id_rsa.pub)
" > $OCP_CREATE_DIR/install-config.yaml && echo "created install-config.yaml" || return 1

echo "INFO: Using multi-architecture release image for Azure: $RELEASE_IMAGE"

# Export the release image override
export OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE=$RELEASE_IMAGE
# Extract the list of CredentialsRequest custom resources (CRs) from the OpenShift Container Platform release image by running the following command:
echo "extracting credential-requests" && oc adm release extract \
  --from=$RELEASE_IMAGE \
  --credentials-requests \
  --included \
  --install-config=$OCP_CREATE_DIR/install-config.yaml \
  --to=$OCP_CREATE_DIR/credentials-requests || return 1 #credential requests are stored in credentials-requests dir

# Create Azure service principal and credentials using ccoctl with retry logic
echo "INFO: Running ccoctl azure create-all with retry logic for eventual consistency handling..."
echo "INFO: Using installation resource group: $CLUSTER_RESOURCE_GROUP"
retry_ccoctl_azure azure create-all \
--name $CLUSTER_NAME \
--subscription-id $AZURE_SUBSCRIPTION_ID \
--tenant-id $AZURE_TENANT_ID \
--region $AZURE_REGION \
--installation-resource-group-name $CLUSTER_RESOURCE_GROUP \
--dnszone-resource-group-name $AZURE_BASEDOMAIN_RESOURCE_GROUP \
--storage-account-name $STORAGE_ACCOUNT_NAME \
--output-dir $OCP_CREATE_DIR \
--credentials-requests-dir $OCP_CREATE_DIR/credentials-requests || return 1

    $OPENSHIFT_INSTALL create manifests --dir $OCP_CREATE_DIR || return 1
    cp $OCP_CREATE_DIR/credentials-requests/* $OCP_CREATE_DIR/manifests/ || return 1 # copy cred requests to manifests dir, ccoctl delete will delete cred requests in separate dir
    
    # Create the cluster with error handling
    if ! $OPENSHIFT_INSTALL create cluster --dir $OCP_CREATE_DIR --log-level=info; then
        cleanup_on_failure "$OCP_CREATE_DIR" "$CLUSTER_NAME" "azure"
        return 1
    fi
    
    echo "azure-tenant-id: $AZURE_TENANT_ID"
    echo "azure-subscription-id: $AZURE_SUBSCRIPTION_ID"
    echo "azure-resource-group: $CLUSTER_RESOURCE_GROUP"
    echo "azure-basedomain-resource-group: $AZURE_BASEDOMAIN_RESOURCE_GROUP"
    
    # Cleanup
    unset OPENSHIFT_INSTALL_RELEASE_IMAGE_OVERRIDE
    [[ -n "$PROCEED_WITH_EXISTING_CLUSTERS" ]] && unset PROCEED_WITH_EXISTING_CLUSTERS
}

# Function to create Velero identity for current Azure OpenShift cluster
# run this after creation above is successful to get vars for velero install for oadp with `make deploy-olm-stsflow-azure`
create-velero-identity-for-azure-cluster() {
    # Get cluster API URL
    local API_URL=$(oc whoami --show-server)
    
    # Extract cluster name from API URL
    # Format: https://api.cluster-name.basedomain:6443
    local CLUSTER_NAME=$(echo "$API_URL" | sed 's|https://api\.||' | sed 's|\..*||')
    
    if [[ -z "$CLUSTER_NAME" ]]; then
        echo "ERROR: Could not determine cluster name from API URL: $API_URL"
        return 1
    fi
    
    echo "Creating Velero identity for cluster: $CLUSTER_NAME"
    
    # Check if this is an Azure cluster by looking for the OIDC resource group
    local AZURE_RESOURCE_GROUP="${CLUSTER_NAME}-oidc"
    if ! az group show --name "$AZURE_RESOURCE_GROUP" &>/dev/null; then
        echo "ERROR: Resource group $AZURE_RESOURCE_GROUP not found. Is this an Azure STS cluster?"
        return 1
    fi
    
    local IDENTITY_NAME="velero"
    
    # Get subscription and tenant from current az login
    local AZURE_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
    local AZURE_TENANT_ID=$(az account show --query tenantId -o tsv)
    
    echo "Using subscription: $AZURE_SUBSCRIPTION_ID"
    echo "Using tenant: $AZURE_TENANT_ID"
    
    # Check if identity already exists
    local IDENTITY_EXISTS=false
    if az identity show -g "$AZURE_RESOURCE_GROUP" -n "$IDENTITY_NAME" &>/dev/null; then
        echo "Identity $IDENTITY_NAME already exists in $AZURE_RESOURCE_GROUP"
        IDENTITY_EXISTS=true
        local IDENTITY_CLIENT_ID=$(az identity show -g "$AZURE_RESOURCE_GROUP" -n "$IDENTITY_NAME" --query clientId -otsv)
        local IDENTITY_PRINCIPAL_ID=$(az identity show -g "$AZURE_RESOURCE_GROUP" -n "$IDENTITY_NAME" --query principalId -otsv)
    else
        echo "Creating managed identity..."
        az identity create \
            --subscription "$AZURE_SUBSCRIPTION_ID" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$IDENTITY_NAME"
        
        local IDENTITY_CLIENT_ID=$(az identity show -g "$AZURE_RESOURCE_GROUP" -n "$IDENTITY_NAME" --query clientId -otsv)
        local IDENTITY_PRINCIPAL_ID=$(az identity show -g "$AZURE_RESOURCE_GROUP" -n "$IDENTITY_NAME" --query principalId -otsv)
        
        # Wait for identity to propagate in Azure AD
        echo "Waiting for identity to propagate in Azure AD..."
        sleep 30
    fi
    
    # Check and assign roles if not already assigned
    echo "Checking role assignments..."
    
    # Check for Contributor role
    if ! az role assignment list --assignee "$IDENTITY_PRINCIPAL_ID" --role "Contributor" --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID" --query "[0]" &>/dev/null; then
        echo "Assigning Contributor role..."
        az role assignment create --role "Contributor" --assignee "$IDENTITY_PRINCIPAL_ID" --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID"
    else
        echo "Contributor role already assigned"
    fi
    
    # Check for Storage Blob Data Contributor role
    if ! az role assignment list --assignee "$IDENTITY_PRINCIPAL_ID" --role "Storage Blob Data Contributor" --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID" --query "[0]" &>/dev/null; then
        echo "Assigning Storage Blob Data Contributor role..."
        az role assignment create --assignee "$IDENTITY_PRINCIPAL_ID" --role "Storage Blob Data Contributor" --scope "/subscriptions/$AZURE_SUBSCRIPTION_ID"
    else
        echo "Storage Blob Data Contributor role already assigned"
    fi
    
    # Get OIDC issuer URL from the cluster
    echo "Getting cluster OIDC issuer URL..."
    local SERVICE_ACCOUNT_ISSUER=$(oc get authentication.config.openshift.io cluster -o json | jq -r .spec.serviceAccountIssuer)
    
    if [[ -z "$SERVICE_ACCOUNT_ISSUER" || "$SERVICE_ACCOUNT_ISSUER" == "null" ]]; then
        echo "ERROR: Could not get OIDC issuer URL from cluster"
        return 1
    fi
    
    # Check if federated credential already exists
    local FED_CRED_NAME="kubernetes-federated-credential"
    if ! az identity federated-credential show \
        --name "$FED_CRED_NAME" \
        --identity-name "$IDENTITY_NAME" \
        --resource-group "$AZURE_RESOURCE_GROUP" &>/dev/null; then
        
        echo "Creating federated identity credential..."
        az identity federated-credential create \
            --name "$FED_CRED_NAME" \
            --identity-name "$IDENTITY_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --issuer "$SERVICE_ACCOUNT_ISSUER" \
            --subject "system:serviceaccount:velero:velero" \
            --audiences "openshift"
    else
        echo "Federated credential $FED_CRED_NAME already exists"
    fi
    
    echo ""
    echo "Velero identity setup complete!"
    echo ""
    echo "Export these variables for the OADP Makefile:"
    echo "export AZURE_CLIENT_ID=$IDENTITY_CLIENT_ID"
    echo "export AZURE_TENANT_ID=$AZURE_TENANT_ID"
    echo "export AZURE_SUBSCRIPTION_ID=$AZURE_SUBSCRIPTION_ID"
    echo ""
    echo "Or run the OADP deployment directly with:"
    echo "make deploy-olm-stsflow-azure AZURE_CLIENT_ID=$IDENTITY_CLIENT_ID AZURE_TENANT_ID=$AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID=$AZURE_SUBSCRIPTION_ID"
    echo ""
    echo "To create Velero credentials file for the instructions:"
    echo "cat << EOF > ./credentials-velero"
    echo "AZURE_SUBSCRIPTION_ID=${AZURE_SUBSCRIPTION_ID}"
    echo "AZURE_RESOURCE_GROUP=${AZURE_RESOURCE_GROUP%-oidc}"
    echo "AZURE_CLOUD_NAME=AzurePublicCloud"
    echo "EOF"
}

# Function to create Azure storage container for Velero backups
create-velero-container-for-azure-cluster() {
    # Get cluster API URL
    local API_URL=$(oc whoami --show-server)
    
    # Extract cluster name from API URL
    # Format: https://api.cluster-name.basedomain:6443
    local CLUSTER_NAME=$(echo "$API_URL" | sed 's|https://api\.||' | sed 's|\..*||')
    
    if [[ -z "$CLUSTER_NAME" ]]; then
        echo "ERROR: Could not determine cluster name from API URL: $API_URL"
        return 1
    fi
    
    echo "Creating Velero storage container for cluster: $CLUSTER_NAME"
    
    # Check if this is an Azure cluster by looking for the cluster resource group
    local AZURE_RESOURCE_GROUP="${CLUSTER_NAME}-rg"
    if ! az group show --name "$AZURE_RESOURCE_GROUP" &>/dev/null; then
        echo "ERROR: Resource group $AZURE_RESOURCE_GROUP not found. Is this an Azure STS cluster?"
        return 1
    fi
    
    # Get subscription from current az login
    local AZURE_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
    
    echo "Using subscription: $AZURE_SUBSCRIPTION_ID"
    echo "Using resource group: $AZURE_RESOURCE_GROUP"
    
    # Storage account name - use same pattern as cluster creation
    local STORAGE_ACCOUNT_NAME=$(echo "$CLUSTER_NAME" | tr -d '-' | tr '[:upper:]' '[:lower:]' | cut -c1-24)
    local CONTAINER_NAME="velero"
    
    # Check if storage account exists anywhere in the subscription
    local EXISTING_RG=$(az storage account show --name "$STORAGE_ACCOUNT_NAME" --query resourceGroup -o tsv 2>/dev/null)
    
    if [[ -n "$EXISTING_RG" ]]; then
        echo "Storage account $STORAGE_ACCOUNT_NAME already exists in resource group: $EXISTING_RG"
        
        # Check if it's in the expected resource group
        if [[ "$EXISTING_RG" != "$AZURE_RESOURCE_GROUP" ]]; then
            echo "WARNING: Storage account exists in a different resource group than expected"
            echo "Expected: $AZURE_RESOURCE_GROUP"
            echo "Actual: $EXISTING_RG"
            echo "Using the existing storage account from resource group: $EXISTING_RG"
            AZURE_RESOURCE_GROUP="$EXISTING_RG"
        fi
    else
        echo "Creating storage account: $STORAGE_ACCOUNT_NAME in resource group: $AZURE_RESOURCE_GROUP"
        if ! az storage account create \
            --name "$STORAGE_ACCOUNT_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --sku Standard_LRS \
            --encryption-services blob \
            --https-only true \
            --kind StorageV2 \
            --access-tier Hot; then
            echo "ERROR: Failed to create storage account"
            return 1
        fi
        
        # Wait for storage account to be ready
        echo "Waiting for storage account to be ready..."
        sleep 10
    fi
    
    # Get storage account key (keys are automatically created with the storage account)
    echo "Retrieving storage account access key..."
    local STORAGE_ACCOUNT_KEY=$(az storage account keys list \
        --account-name "$STORAGE_ACCOUNT_NAME" \
        --resource-group "$AZURE_RESOURCE_GROUP" \
        --query "[0].value" -o tsv 2>/dev/null)
    
    if [[ -z "$STORAGE_ACCOUNT_KEY" ]]; then
        echo "ERROR: Could not retrieve storage account key"
        echo "This might be due to insufficient permissions or the storage account not being fully provisioned"
        echo "Attempting to regenerate key..."
        
        # Try to regenerate the key
        if az storage account keys renew \
            --account-name "$STORAGE_ACCOUNT_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --key primary &>/dev/null; then
            
            # Try to get the key again
            STORAGE_ACCOUNT_KEY=$(az storage account keys list \
                --account-name "$STORAGE_ACCOUNT_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --query "[0].value" -o tsv 2>/dev/null)
        fi
        
        if [[ -z "$STORAGE_ACCOUNT_KEY" ]]; then
            echo "ERROR: Still unable to retrieve storage account key after regeneration attempt"
            return 1
        fi
    fi
    
    # Check if container exists
    if az storage container show \
        --name "$CONTAINER_NAME" \
        --account-name "$STORAGE_ACCOUNT_NAME" \
        --account-key "$STORAGE_ACCOUNT_KEY" &>/dev/null; then
        echo "Container $CONTAINER_NAME already exists in storage account $STORAGE_ACCOUNT_NAME"
    else
        echo "Creating container: $CONTAINER_NAME"
        az storage container create \
            --name "$CONTAINER_NAME" \
            --account-name "$STORAGE_ACCOUNT_NAME" \
            --account-key "$STORAGE_ACCOUNT_KEY" \
            --public-access off
    fi
    
    echo ""
    echo "Velero storage container setup complete!"
    echo ""
    echo "Storage configuration:"
    echo "  Storage Account: $STORAGE_ACCOUNT_NAME"
    echo "  Container: $CONTAINER_NAME"
    echo "  Resource Group: $AZURE_RESOURCE_GROUP"
    echo ""
    echo "To configure Velero with this storage:"
    echo "1. Ensure you have run 'create-velero-identity-for-azure-cluster' first"
    echo "2. Use the following in your BackupStorageLocation:"
    echo "   storageAccount: $STORAGE_ACCOUNT_NAME"
    echo "   resourceGroup: $AZURE_RESOURCE_GROUP"
    echo "   container: $CONTAINER_NAME"
    echo ""
    echo "To retrieve the storage account key later:"
    echo "  az storage account keys list \\"
    echo "    --account-name $STORAGE_ACCOUNT_NAME \\"
    echo "    --resource-group $AZURE_RESOURCE_GROUP \\"
    echo "    --query \"[0].value\" -o tsv"
    echo ""
    echo "To show the current key:"
    echo "  export AZURE_STORAGE_ACCOUNT_KEY=\"\$(az storage account keys list --account-name $STORAGE_ACCOUNT_NAME --resource-group $AZURE_RESOURCE_GROUP --query '[0].value' -o tsv)\""
}
